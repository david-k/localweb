{
	"compilerOptions": {
		"strict": true,
		"lib": ["dom", "dom.iterable", "es2022"],
		"target": "es2022",
		"module": "nodenext",
		"noEmit": true,

		// Needed for Lit's @property() decorator: https://lit.dev/docs/components/decorators/#decorators-typescript
		"experimentalDecorators": true,

		// Normally, TypeScript class fields are simply translated to
		// JavaScript class fields. However, class fields shadow the accessors
		// (setters/getters) that are automatically generated by Lit (it
		// doesn't matter whether you use the @property() decorator or the
		// static `properties` field). The effect of this option is that
		// TypeScript class fields are *not* translated to JavaScript class
		// fields but instead assigned to in the constructor.
		// See https://lit.dev/docs/components/properties/#avoiding-issues-with-class-fields
		//
		// Alternatively, I could use the newly standardized auto-accessors
		// feature instead of TypeScripts experimentalDecorators, but browsers
		// do not support them yet and esbuild cannot transform them.
		"useDefineForClassFields": false,

		// Both `experimentalDecorators` and `useDefineForClassFields` affect
		// the semantics of the code and need to be taken into account by the
		// build tool. Fortunately, esbuild reads the tsconfig.json config and
		// supports these options: https://esbuild.github.io/content-types/#tsconfig-json
	},
	"include": [
		"popup/*.ts"
  ]
}
